オブジェクトの生成と管理

オブジェクトの生成をFactoryクラスで行い、
生成されたオブジェクトの管理をManagerクラスで行う設計としManager内ではObject Poolパターンを使用してオブジェクトの再利用を行う。

1. Factoryクラス
- オブジェクトの生成を担当するクラス。
- createObjectメソッドを持ち、新しいオブジェクトを生成して返す。
- シングルトンパターンを使用して、Factoryクラスのインスタンスは一つだけにする。

2. Managerクラス
- 生成されたオブジェクトの管理を担当するクラス。
- Object Poolパターンを使用して、オブジェクトの再利用を行う。
- getObjectメソッドを持ち、利用可能なオブジェクトを返す。利用可能なオブジェクトがない場合はFactoryクラスを使用して新しいオブジェクトを生成する。
- releaseObjectメソッドを持ち、使用が終わったオブジェクトをプールに戻す。
- シングルトンパターンを使用して、Managerクラスのインスタンスは一つだけにしオブジェクトの一元管理を行う。

3. ObjectPoolクラス
- オブジェクトのプールを管理するクラス。
- プール内のオブジェクトのリストを保持し、オブジェクトの取得と返却を行うAPIを提供する。
- オブジェクトの実質的な管理者はManagerクラスとする。(ManagerクラスがObjectPoolクラスを利用する形)

4. Objectクラス
- 管理されるオブジェクトの基底クラス。
- このクラスを継承して具体的なオブジェクトクラスを作成する。
- InitObjectは、オブジェクト生成直後に一度だけ呼ばれる初期化メソッド。
- Startは、シーン等に配置されたオブジェクトがアクティブになった際に一度だけ呼ばれるメソッド。

5. ObjectHandlerクラス
- オブジェクトのライフサイクルを管理するクラス。
- オブジェクトの初期化、リセット、破棄などの処理を担当する。
- Managerクラスと連携して、オブジェクトの状態管理を行う。
- Object実態との関連付けを持ち、オブジェクトの状態変更を監視する。
- オブジェクトの識別子を保持し、オブジェクトの状態変更に応じて識別子を更新する。
- シーンではオブジェクトの生成、利用、破棄の各段階でObjectHandlerを介してオブジェクトを操作する。

6. ObjectGroupクラス
- 複数のオブジェクトをグループ化して管理するクラス。
- グループ内のオブジェクトに対して一括で操作を行うAPIを提供する。
- これはシーン内で関連するオブジェクトをまとめて管理するのに役立つ。

7. オブジェクトの判別方法
インデックス + 世代番号
- 各オブジェクトにはインデックスと世代番号を持たせ、オブジェクトの一意性を確保する。
- インデックスはオブジェクトがプールに追加される際に割り当てられ、世代番号はオブジェクトが再利用されるたびにインクリメントされる。
- オブジェクトの識別には「インデックス:世代番号」の形式を使用する。
例: 5:2 （インデックス5、世代番号2のオブジェクト）

※ ObjectGroup と ObjectManager の違い
- ObjectManager は全オブジェクトの一元管理を行うクラスであり、オブジェクトの生成、取得、破棄を担当する。
- ObjectGroup は関連するオブジェクトをまとめて管理するクラスであり、グループ内のオブジェクトに対して一括操作を行う。
    例　: 敵キャラクターグループ、アイテムグループなど

生成時の注意点
- 型検査: テンプレート生成では `static_assert(std::is_base_of<GameObject, T>::value, "...")` によるコンパイル時チェックを行う。ランタイムマクロにカンマ式を渡すとプリプロセッサで分割されるため避ける。
- 初期化順序: `Factory::CreateObject<T>` で `InitObject()` を呼ぶ設計にしておくと、生成直後で必要な初期化が確実に行われる。`Start()` はシーン側で呼ぶのが望ましい（タイミング管理のため）。
- ハンドルの扱い: `ObjectHandle`（index+generation）は軽量な識別子。`Create` は `ObjectHandle` を返し、実体参照が必要な場合は `Get<T>(handle)` を使う。直接 `GameObject*` を長期間保持しない。
- Releaseの意味: `Release(handle)` はスロットの所有を解放し世代をインクリメントする（古いハンドルを無効化）。ただし外部が `shared_ptr` を保持している場合、そのオブジェクトは即時に破棄されない点に注意。
- スレッド安全: Pool/Manager の内部は `mutex` 等で保護する。クリティカルセクションは短く保つ。
- 例外安全: 生成中に例外が出てもプールの状態を壊さないこと。`shared_ptr` を利用して RAII を守る。
- プールのサイズ管理: 事前にプールをプリアロケートするか、最大値制限を考慮する（メモリ使用量とフラグメンテーション対策）。
- シリアライズ: `ObjectHandle::ToUint64()` を用いてハンドルを保存し、復元は `FromUint64()` → `IsValid()` で検査する。
- デバッグ表示: `ObjectManager::DrawObjectCount(x,y)` や `ObjectHandle::ToString()` で状態を可視化すると原因追跡が容易。

用語集
- Factoryパターン: オブジェクトの生成を専門に行うクラスを設けるデザインパターン。
- Object Poolパターン: オブジェクトの生成と破棄のコストを削減するために、オブジェクトを再利用するデザインパターン。
- インデックス + 世代番号: オブジェクトの一意性を確保するための識別方法。
- インデックス: オブジェクトがプールに追加される際に割り当てられる番号。
- 世代番号: オブジェクトが再利用されるたびにインクリメントされる番号。
- ストック: Object Pool内で利用可能なオブジェクトの集合。
- ハンドル: オブジェクトを識別するための軽量な識別子（インデックス + 世代番号）。
- グループ: 関連するオブジェクトをまとめて管理するための単位。

